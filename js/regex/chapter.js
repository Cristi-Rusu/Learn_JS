/* Regular Expressions */

let re1 = new RegExp('abc');
let re2 = /abc/;
// escape the '+' character in a regular expression
let eighteenPlus = /eighteen\+/;

console.log('"abc" is contained in "abcdef" -', /abc/.test('abcdef'));
console.log('"abc" is contained in "abxfg" -', /abc/.test('abxfg'));

console.log('"in 1992" contains digits -', /[0123456789]/.test('in 1992'));
// is equivalent to:
console.log('"in 1992" contains digits -', /[0-9]/.test('in 1992'));

//  hyphen (-) between two characters indicate a range ordered by the character's Unicode number
//  \d  -  any digit character
//  \w  -  an alphanumeric character ("word character")
//  \s  -  any whitespace character
//  \D  -  a character that is not a digit
//  \W  -  a nonalphanumeric character
//  \S  -  a nonwhitespace character
//  .   -  any character except for newline
//  +   -  the element before it can be repeated several times
//  *   -  has e similar meaning to '+' but allows the pattern to math zero times
//  ?   -  the element before it is optional


let dateTime = /\d\d-\d\d-\d\d\d\d \d\d:\d\d/;
console.log('"01-30-2003 15:20" - right format -', dateTime.test('01-30-2003 15:20'));
console.log('"01-jan-2003 15:20" - right format -', dateTime.test('01-jan-2003 15:20'));

// match any character except for '0' and '1'
let notBinary = /[^01]/;
console.log('"1100100010100110" contains characters except "0" and "1"', notBinary.test('1100100010100110'));
console.log('"4105103010200110" contains characters except "0" and "1"', notBinary.test('4105103010200110'));

let num = /\d+/;
console.log(num.exec('commit 3552541c871d18'));

let quotedText = /"([^"]*)"/;
console.log(quotedText.exec('say "hello"'));

console.log(/bad(ly)?/.exec("bad"));
console.log(/(\d)+/.exec("1232 some more 23421"));

console.log(new Date());

function getDateFrom(string) {
    // \b  -  sets a word boundary; if the character number exceeds the boundary set, the pattern doesn't match
    let dateFormat = /\b(\d{1,2})-(\d{1,2})-(\d{4})\b/;
    // get the variables from the array generated by the 'exec' function
    // the '_' variable is used to escape the full string returned by the 'exec' function as the first item in the array
    let [_, month, day, year] = dateFormat.exec(string);
    return new Date(year, month, day);
};

console.log(getDateFrom('10-1-3000'));

// Choice patterns
// the pipe character (|) stands for the 'or' operator in a RegExp
let animalCount = /\b\d+ (pig|cow|chicken)s?\b/;
console.log(animalCount.test('15 chickens'));
console.log(animalCount.test('25 pigcows'));

let nameList = 'Liskov, Barbara\nMcCarthy, John\nWadler, Philip';
// swap the last and first name and remove the commas
nameList = nameList.replace(/(\w+), (\w+)/g, '$2 $1');
console.log(nameList);

// functions can be passed as the second argument for the replace method
let randString = 'the cia and fbi';
randString = randString.replace(/\b(cia|fbi)\b/g, str => str.toUpperCase());
console.log(randString);


let stock = '1 lemon, 2 cabbages, 101 eggs';
// the matched string is passed as the first argument, then the groups in consecutive order(ex: matched string, $1, $2)
function minusOne( match, amount, unit ) {
    amount = Number(amount) - 1;
    if ( amount === 1 ) {
        // remove the 's' at the end(only one left)
        unit = unit.slice(0, unit.length - 1);
    } else if ( amount === 0 ) {
        amount = 'no';
    }
    return amount + ' ' + unit;
}
stock = stock.replace(/(\d+) (\w+)/g, minusOne);
console.log(stock);

// Greedy operators (+, *, ?, {})
// they are called greedy because they match as much as they can
// to make them nongreedy, add a '?' after them (+?, *?, ??, {}?)

// greedy operators
function stripCommentsG( string ) {
    return string.replace(/\/\/.*|\/\*[^]*\*\//, '');
    // .*    -  matches any sequence of characters Except for new line
    // [^]*  -  matches any sequence of characters Including new line
}

console.log(stripCommentsG('1 /* one */ + /* two */ 2'));
// -> 1  2
// not what expected

function stripCommentsNG( string ) {
    return string.replace(/\/\/.*|\/\*[^]*?\*\//, '');
    // [^]*?  -  '?' character makes the operator nongreedy, meaning it will match as little as possible
}

console.log('1 /* one */ + /* two */ 2');
// -> 1 + 2
// the right output

// Often times the nongreedy operators work better, so try them first

// Dynamically creating RegExp objects
let name = 'harry';
let text = 'Harry is a suspicious character.';
// 'gi' stands for global and case insensitive
let regexp = new RegExp('\\b(' + name + ')\\b', 'gi');
console.log(text.replace(regexp, '_$1_'));

// Escaping strings
let username = 'dea+hl[]rd';
let sentence = 'This dea+hl[]rd guy is super annoying.';
let escaped = username.replace(/[\\[.+*?(){|^$]/g, '\\$&');
let reg = new RegExp('\\b' + escaped + '\\b', 'gi');
console.log(sentence.replace(reg, '_$&_'));

// Search method
// matches any non-whitespace character
console.log('  word'.search(/\S/));
// -> 2
console.log('    '.search(/\S/));
// -> -1


// TODO: parse function for INI file
