/* Regular Expressions */

const re1 = new RegExp('abc');
const re2 = /abc/;
// thought they are both regular expressions, they are not equal
console.log(re1 === re2);
// escape the '+' character in a regular expression
const eighteenPlus = /eighteen\+/;
console.log('"eighteen+" is contained in "13eighteen+kja"',
    eighteenPlus.test('13eighteen+kja'));
console.log('"abc" is contained in "abcdef" -', /abc/.test('abcdef'));
console.log('"abc" is contained in "abxfg" -', /abc/.test('abxfg'));

console.log('"in 1992" contains digits -', /[0123456789]/.test('in 1992'));
// is equivalent to:
console.log('"in 1992" contains digits -', /[0-9]/.test('in 1992'));

//  hyphen (-) between two characters indicate a range ordered by the character's Unicode number
//  \d  -  any digit character
//  \w  -  an alphanumeric character ("word character")
//  \s  -  any whitespace character
//  \D  -  a character that is not a digit
//  \W  -  a nonalphanumeric character
//  \S  -  a nonwhitespace character
//  .   -  any character except for newline
//  +   -  the element before it can be repeated several times
//  *   -  has e similar meaning to '+' but allows the pattern to math zero times
//  ?   -  the element before it is optional


const dateTime = /\d\d-\d\d-\d\d\d\d \d\d:\d\d/;
console.log('"01-30-2003 15:20" - right format -',
    dateTime.test('01-30-2003 15:20'));
console.log('"01-jan-2003 15:20" - right format -',
    dateTime.test('01-jan-2003 15:20'));

// match any character except for '0' and '1'
const notBinary = /[^01]/;
console.log('"4105103010200110" contains characters except "0" and "1"',
    notBinary.test('4105103010200110'));
console.log('"1100100010100110" contains characters except "0" and "1"',
    notBinary.test('1100100010100110'));

const num = /\d+/;
console.log(num.exec('commit 3552541c871d18'));

const quotedText = /"([^"]*)"/;
console.log(quotedText.exec('say "hello"'));

console.log(/bad(ly)?/.exec('bad'));
console.log(/(\d)+/.exec('1232 some more 23421'));

console.log(new Date());

function getDateFrom(string) {
    // \b  -  sets a word boundary; if the character number exceeds the boundary set, the pattern doesn't match
    const dateFormat = /\b(\d{1,2})-(\d{1,2})-(\d{4})\b/;
    // get the variables from the array generated by the 'exec' function
    // the '_' variable is used to escape the full string returned by the 'exec' function as the first item in the array
    // eslint-disable-next-line no-unused-vars
    const [_, month, day, year] = dateFormat.exec(string);
    return new Date(year, month, day);
}

console.log(getDateFrom('10-1-3000'));

// Choice patterns
// the pipe character (|) stands for the 'or' operator in a RegExp
const animalCount = /\b\d+ (pig|cow|chicken)s?\b/;
console.log(animalCount.test('15 chickens'));
console.log(animalCount.test('25 pigcows'));

let nameList = 'Liskov, Barbara\nMcCarthy, John\nWadler, Philip';
// swap the last and first name and remove the commas
nameList = nameList.replace(/(\w+), (\w+)/g, '$2 $1');
console.log(nameList);

// functions can be passed as the second argument for the replace method
let randString = 'the cia and fbi';
randString = randString.replace(/\b(cia|fbi)\b/g, str => str.toUpperCase());
console.log(randString);


let stock = '1 lemon, 2 cabbages, 101 eggs';
// the matched string is passed as the first argument, then the groups in consecutive order(ex: matched string, $1, $2)
function minusOne(match, amount, unit) {
    amount = Number(amount) - 1;
    if (amount === 1) {
    // remove the 's' at the end(only one left)
        unit = unit.slice(0, unit.length - 1);
    } else if (amount === 0) {
        amount = 'no';
    }
    return `${amount} ${unit}`;
}
stock = stock.replace(/(\d+) (\w+)/g, minusOne);
console.log(stock);

// Greedy operators (+, *, ?, {})
// they are called greedy because they match as much as they can
// to make them nongreedy, add a '?' after them (+?, *?, ??, {}?)

// greedy operators
function stripCommentsG(string) {
    return string.replace(/\/\/.*|\/\*[^]*\*\//, '');
    // .*    -  matches any sequence of characters Except for new line
    // [^]*  -  matches any sequence of characters Including new line
}

console.log(stripCommentsG('1 /* one */ + /* two */ 2'));
// -> 1  2
// not what expected

function stripCommentsNG(string) {
    return string.replace(/\/\/.*|\/\*[^]*?\*\//, '');
    // [^]*?  -  '?' character makes the operator nongreedy, meaning it will match as little as possible
}

console.log(stripCommentsNG('1 /* one */ + /* two */ 2'));
// -> 1 + 2
// the right output

// Often times the nongreedy operators work better, so try them first

// Dynamically creating RegExp objects
const name = 'harry';
const text = 'Harry is a suspicious character.';
// 'gi' stands for global and case insensitive
const regexp = new RegExp(`\\b(${name})\\b`, 'gi');
console.log(text.replace(regexp, '_$1_'));

// Escaping strings
const username = 'dea+hl[]rd';
const sentence = 'This dea+hl[]rd guy is super annoying.';
const escaped = username.replace(/[\\[.+*?(){|^$]/g, '\\$&');
const reg = new RegExp(`\\b${escaped}\\b`, 'gi');
console.log(sentence.replace(reg, '_$&_'));

// Search method
// matches any non-whitespace character
console.log('  word'.search(/\S/));
// -> 2
console.log('    '.search(/\S/));
// -> -1

const input = 'A string with 3 numbers in it... 42 and 88.';
const number = /\b\d+\b/g;
let matches;
// eslint-disable-next-line no-cond-assign
while (matches = number.exec(input)) {
    console.log(`Found ${matches[0]}, at index ${matches.index}`);
    console.log('The RegExp lastIndex after the match', number.lastIndex);
}

// creates an object containing the information from the INI file/string
function parseINI(string) {
    // eslint-disable-next-line prefer-const
    let result = {};
    let section = result;
    const matchInfo = str => str.match(/^(\w+)=(.+)$/);
    const matchNewSection = str => str.match(/^\[(\w+)\]$/);
    // matches an empty line or comment
    const matchEmpty = str => str.match(/^\s*(;.*)?$/);
    // split the string into separate lines
    string.split(/\r?\n/).forEach((line) => {
        let match;
        if (matchInfo(line)) {
            match = matchInfo(line);
            // add a new key and property
            section[match[1]] = match[2];
        } else if (matchNewSection(line)) {
            match = matchNewSection(line);
            // create an empty object value for the matched key
            result[match[1]] = {};
            // update the section; the next lines' information will be stored in this section
            section = result[match[1]];
        } else if (!matchEmpty(line)) {
            throw new Error(`Line: "${line}" is nos valid`);
        }
    });
    return result;
}

console.log(parseINI(`
searchengine=https://duckduckgo.com/?q=$1
spitefulness=9.7

; comments are preceded by a semicolon...
; each section concerns an individual enemy
[larry]
fullname=Larry Doe
type=kindergarten bully
website=http://www.geocities.com/CapeCanaveral/11451

[davaeorn]
fullname=Davaeorn
type=evil wizard
outputdir=/home/marijn/enemies/davaeorn
`));
